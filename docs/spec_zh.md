# 需求收集生成

工作流阶段：需求收集

首先，基于功能想法以 EARS 格式生成初始需求集，然后与用户迭代以完善需求，直到需求完整准确。

在此阶段不要专注于代码探索。相反，只需专注于编写需求，这些需求稍后将转化为设计。

**约束条件：**

- 模型必须创建 '.claude/specs/{feature_name}/requirements.md' 文件（如果尚不存在）
- 模型必须基于用户的粗略想法生成需求文档的初始版本，而不是先提出连续的问题
- 模型必须按以下格式编排初始的 requirements.md 文档：
  - 清晰的介绍部分，总结功能特性
  - 层次化的编号需求列表，每个需求包含：
    - 格式为"作为[角色]，我想要[功能]，以便[收益]"的用户故事
    - 以 EARS 格式（Easy Approach to Requirements Syntax）编写的编号验收标准列表
  - 示例格式：
[此处包含示例格式]
- 模型应该在初始需求中考虑边缘情况、用户体验、技术约束和成功标准
- 更新需求文档后，模型必须询问用户"需求看起来合适吗？如果是，我们可以继续进行设计。"
- 如果用户请求更改或未明确批准，模型必须修改需求文档
- 模型必须在每次编辑需求文档后请求明确批准
- 模型必须在收到明确批准（如"是"、"批准"、"看起来不错"等）之前不得继续进行设计文档
- 模型必须继续反馈-修订循环，直到收到明确批准
- 模型应该建议需求可能需要澄清或扩展的具体领域
- 模型可以就需要澄清的需求的特定方面提出有针对性的问题
- 当用户对特定方面不确定时，模型可以建议选项
- 用户接受需求后，模型必须进入设计阶段


# 设计文档创建生成

工作流阶段：设计文档创建

用户批准需求后，您应该基于功能需求开发全面的设计文档，在设计过程中进行必要的研究。
设计文档应该基于需求文档，因此请确保需求文档首先存在。

**约束条件：**

- 模型必须创建 '.claude/specs/{feature_name}/design.md' 文件（如果尚不存在）
- 模型必须基于功能需求识别需要研究的领域
- 模型必须进行研究并在对话线程中建立上下文
- 模型不应创建单独的研究文件，而是应该将研究作为设计和实施计划的上下文
- 模型必须总结将影响功能设计的关键发现
- 模型应该引用来源并在对话中包含相关链接
- 模型必须在 '.claude/specs/{feature_name}/design.md' 创建详细的设计文档
- 模型必须将研究发现直接纳入设计过程
- 模型必须在设计文档中包含以下部分：
  - 概述
  - 架构
  - 组件和接口
  - 数据模型
  - 错误处理
  - 测试策略
- 模型应该在适当时包含图表或视觉表示（如果适用，使用 Mermaid 绘制图表）
- 模型必须确保设计涵盖在澄清过程中确定的所有功能需求
- 模型应该突出设计决策及其理由
- 模型可以在设计过程中就特定技术决策征求用户意见
- 更新设计文档后，模型必须询问用户"设计看起来合适吗？如果是，我们可以继续进行实施计划。"
- 如果用户请求更改或未明确批准，模型必须修改设计文档
- 模型必须在每次编辑设计文档后请求明确批准
- 模型必须在收到明确批准（如"是"、"批准"、"看起来不错"等）之前不得继续进行实施计划
- 模型必须继续反馈-修订循环，直到收到明确批准
- 模型必须在继续之前将所有用户反馈纳入设计文档
- 如果在设计期间发现差距，模型必须提供返回功能需求澄清的选项

# 实施规划生成

工作流阶段：实施规划

用户批准设计后，基于需求和设计创建包含编码任务清单的可操作实施计划。
任务文档应该基于设计文档，因此请确保设计文档首先存在。

**约束条件：**

- 模型必须创建 '.claude/specs/{feature_name}/tasks.md' 文件（如果尚不存在）
- 如果用户表示需要对设计进行任何更改，模型必须返回设计步骤
- 如果用户表示我们需要额外的需求，模型必须返回需求步骤
- 模型必须在 '.claude/specs/{feature_name}/tasks.md' 创建实施计划
- 模型在创建实施计划时必须使用以下特定说明：将功能设计转换为一系列提示，供代码生成 LLM 以测试驱动的方式实施每个步骤。优先考虑最佳实践、渐进式进展和早期测试，确保在任何阶段都没有复杂性的大跳跃。确保每个提示都建立在之前的提示基础上，并以将内容连接在一起结束。不应该有未集成到前一步骤的悬空或孤立代码。仅专注于涉及编写、修改或测试代码的任务。
- 模型必须将实施计划格式化为编号复选框列表，最多两级层次结构：
  - 顶级项目（如史诗）仅在需要时使用
  - 子任务应使用十进制符号编号（例如，1.1、1.2、2.1）
  - 每个项目必须是复选框
  - 优先选择简单结构
- 模型必须确保每个任务项包括：
  - 作为任务描述的明确目标，涉及编写、修改或测试代码
  - 作为任务下子项目符号的附加信息
  - 对需求文档中需求的具体引用（引用细粒度的子需求，而不仅仅是用户故事）
- 模型必须确保实施计划是一系列离散的、可管理的编码步骤
- 模型必须确保每个任务引用需求文档中的特定需求
- 模型必须不包含设计文档中已涵盖的过多实施细节
- 模型必须假设所有上下文文档（功能需求、设计）在实施期间都可用
- 模型必须确保每个步骤都以渐进方式建立在前面的步骤之上
- 模型应该在适当的地方优先考虑测试驱动开发
- 模型必须确保计划涵盖可以通过代码实施的设计的所有方面
- 模型应该对步骤进行排序，以通过代码尽早验证核心功能
- 模型必须确保所有需求都被实施任务覆盖
- 如果在实施规划期间发现差距，模型必须提供返回前面步骤（需求或设计）的选项
- 模型必须仅包含可由编码代理执行的任务（编写代码、创建测试等）
- 模型必须不包含与用户测试、部署、性能指标收集或其他非编码活动相关的任务
- 模型必须专注于可以在开发环境中执行的代码实施任务
- 模型必须通过遵循以下准则确保每个任务都可由编码代理执行：
  - 任务应涉及编写、修改或测试特定的代码组件
  - 任务应指定需要创建或修改哪些文件或组件
  - 任务应该足够具体，以便编码代理可以执行它们而无需额外澄清
  - 任务应专注于实施细节而不是高级概念
  - 任务应限定于特定的编码活动（例如，"实现 X 函数"而不是"支持 X 功能"）
- 模型必须明确避免在实施计划中包含以下类型的非编码任务：
  - 用户验收测试或用户反馈收集
  - 部署到生产或暂存环境
  - 性能指标收集或分析
  - 运行应用程序以测试端到端流程。但是，我们可以编写自动化测试以从用户角度测试端到端
  - 用户培训或文档创建
  - 业务流程变更或组织变更
  - 营销或沟通活动
  - 任何无法通过编写、修改或测试代码完成的任务
- 更新任务文档后，模型必须询问用户"任务看起来合适吗？"
- 如果用户请求更改或未明确批准，模型必须修改任务文档。
- 模型必须在每次编辑任务文档后请求明确批准。
- 模型必须在收到明确批准（如"是"、"批准"、"看起来不错"等）之前不得认为工作流已完成。
- 模型必须继续反馈-修订循环，直到收到明确批准。
- 一旦任务文档获得批准，模型必须停止。

**此工作流仅用于创建设计和规划工件。功能的实际实施应通过单独的工作流完成。**

- 模型必须不尝试将功能实施作为此工作流的一部分
- 一旦创建了设计和规划工件，模型必须清楚地向用户传达此工作流已完成
- 模型必须通知用户，他们可以通过打开 tasks.md 文件并点击任务项旁边的"开始任务"来开始执行任务。